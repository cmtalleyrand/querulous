<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Harmonic Analysis Lab</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: 'Menlo', 'Consolas', 'Monaco', monospace; font-size: 13px; background: #1a1a2e; color: #e0e0e0; padding: 20px; }
  h1 { font-size: 18px; color: #7ec8e3; margin-bottom: 12px; }
  .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 10px; }
  label { color: #aaa; }
  input, select, button { font-family: inherit; font-size: 13px; background: #16213e; color: #e0e0e0; border: 1px solid #444; padding: 6px 10px; border-radius: 4px; }
  input:focus, select:focus { outline: none; border-color: #7ec8e3; }
  button { background: #0f3460; cursor: pointer; border-color: #7ec8e3; }
  button:hover { background: #1a4a7a; }
  .presets { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 14px; }
  .presets button { font-size: 11px; padding: 3px 8px; background: #1a1a3e; }
  #output { white-space: pre; background: #0f0f1a; border: 1px solid #333; border-radius: 6px; padding: 16px; overflow-x: auto; line-height: 1.5; max-height: 80vh; overflow-y: auto; }
</style>
</head>
<body>
<h1>Harmonic Analysis Lab</h1>
<div class="controls">
  <label>Melody: <input id="mel" value="C E G B A F A C" size="30" /></label>
  <label>Duration:
    <select id="dur">
      <option value="2">Half</option>
      <option value="1" selected>Quarter</option>
      <option value="0.5">Eighth</option>
      <option value="0.25">Sixteenth</option>
    </select>
  </label>
  <button onclick="runAll()">Run all durations</button>
  <button onclick="runOne()">Run selected</button>
</div>
<div class="presets">
  <label>Presets:</label>
  <button onclick="setMel('C E G B A F A C')">C E G B A F A C</button>
  <button onclick="setMel('C E G')">C E G</button>
  <button onclick="setMel('C E G B')">C E G B</button>
  <button onclick="setMel('C D E F G A B C')">Scale</button>
  <button onclick="setMel('C E G C E G C')">Arp C</button>
  <button onclick="setMel('D F A C')">Dm7</button>
</div>
<pre id="output">Click "Run" to start.</pre>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// All lab code inlined below — no imports, no server needed.
// ═══════════════════════════════════════════════════════════════════════════════

const DECAY_RATE = 0.3;
const PASSING_NOTE_THRESHOLD = 0.125;
const MIN_SALIENCE = 0.025;
const NON_CHORD_TONE_FLOOR = 0.05;
const COMPLEXITY_PENALTY = 0.05;

const CHORD_TYPES = {
  major:       { intervals: [0, 4, 7],     required: [0, 4],         complexity: 1 },
  minor:       { intervals: [0, 3, 7],     required: [0, 3],         complexity: 1 },
  diminished:  { intervals: [0, 3, 6],     required: [0, 3, 6],     complexity: 2 },
  augmented:   { intervals: [0, 4, 8],     required: [0, 4, 8],     complexity: 2 },
  dominant_7:  { intervals: [0, 4, 7, 10], required: [0, 4, 10],    complexity: 3 },
  major_7:     { intervals: [0, 4, 7, 11], required: [0, 4, 11],    complexity: 3 },
  minor_7:     { intervals: [0, 3, 7, 10], required: [0, 3, 10],    complexity: 3 },
  half_dim_7:  { intervals: [0, 3, 6, 10], required: [0, 3, 6, 10], complexity: 4 },
  dim_7:       { intervals: [0, 3, 6, 9],  required: [0, 3, 6, 9],  complexity: 4 },
  min_maj_7:   { intervals: [0, 3, 7, 11], required: [0, 3, 11],    complexity: 4 },
  major_6:     { intervals: [0, 4, 7, 9],  required: [0, 4, 9],     complexity: 3 },
  minor_6:     { intervals: [0, 3, 7, 9],  required: [0, 3, 9],     complexity: 3 },
};

const NOTE_NAMES = ['C','Db','D','Eb','E','F','F#','G','Ab','A','Bb','B'];
const TYPE_SHORT = {
  major:'', minor:'m', diminished:'dim', augmented:'aug',
  dominant_7:'7', major_7:'maj7', minor_7:'m7',
  half_dim_7:'m7b5', dim_7:'dim7', min_maj_7:'m(maj7)',
  major_6:'6', minor_6:'m6',
};

function cn(root, type) { return NOTE_NAMES[root] + (TYPE_SHORT[type] ?? type); }
function pcName(pc) { return NOTE_NAMES[((pc % 12) + 12) % 12]; }

function metricMult(onset) {
  const pos = ((onset % 4) + 4) % 4;
  if (pos < 0.01) return 1.2;
  if (Math.abs(pos - 2) < 0.01) return 1.0;
  if (Math.abs(pos - 1) < 0.01 || Math.abs(pos - 3) < 0.01) return 0.75;
  if (Math.abs(pos % 0.5) < 0.01) return 0.5;
  return 0.4;
}

function makeNotes(pitchNames, duration) {
  const map = { C:60, D:62, E:64, F:65, G:67, A:69, B:71 };
  let onset = 0;
  return pitchNames.map(name => {
    const n = { pitch: map[name], onset, duration };
    onset += duration;
    return n;
  });
}

function approachMult(interval) {
  if (interval === null) return 1.0;
  const a = Math.abs(interval);
  if (a === 0) return 1.0;
  if (a <= 2) return 0.8;
  if (a <= 4) return 1.0;
  if (a === 5 || a === 7 || a === 12) return 1.2;
  return 1.0;
}

function preprocessNotes(notes) {
  const segments = [];
  for (let i = 0; i < notes.length; i++) {
    const note = notes[i];
    const prev = i > 0 ? notes[i - 1] : null;
    const app = approachMult(prev ? note.pitch - prev.pitch : null);
    const end = note.onset + note.duration;
    for (let b = Math.floor(note.onset); b < end; b++) {
      const s = Math.max(note.onset, b);
      const e = Math.min(end, b + 1);
      if (e <= s) continue;
      segments.push({ pitch: note.pitch, pitchClass: note.pitch % 12, onset: s, duration: e - s, approach: app });
    }
  }
  return segments;
}

function salience(seg, decay) {
  const raw = (seg.duration - PASSING_NOTE_THRESHOLD) * metricMult(seg.onset) * seg.approach;
  return Math.max(raw, MIN_SALIENCE) * decay;
}

function collectPast(segments, beat) {
  const out = [];
  for (const seg of segments) {
    const sb = Math.floor(seg.onset);
    if (sb > beat) break;
    const dist = beat - sb;
    const d = Math.max(1.0 - dist * DECAY_RATE, 0);
    if (d <= 0) continue;
    out.push({ pitchClass: seg.pitchClass, pitch: seg.pitch, salience: salience(seg, d), onset: seg.onset, decay: d });
  }
  return out;
}

function collectBidirectional(segments, beat) {
  const out = [];
  for (const seg of segments) {
    const sb = Math.floor(seg.onset);
    const dist = Math.abs(beat - sb);
    const d = Math.max(1.0 - dist * DECAY_RATE, 0);
    if (d <= 0) continue;
    out.push({ pitchClass: seg.pitchClass, pitch: seg.pitch, salience: salience(seg, d), onset: seg.onset, decay: d });
  }
  return out;
}

function memberWeight(interval) {
  const n = ((interval % 12) + 12) % 12;
  if (n === 0) return 1.1;
  if (n === 3 || n === 4) return 1.0;
  if (n === 7 || n === 10 || n === 11) return 0.8;
  return 0.6;
}

function scoreChord(root, typeName, notes) {
  const def = CHORD_TYPES[typeName];
  const pcs = new Set(notes.map(n => n.pitchClass));
  for (const req of def.required) { if (!pcs.has((root + req) % 12)) return null; }
  if (notes.length < 2) return null;
  let matchedSal = 0, nctPen = 0;
  const matched = [], nct = [];
  let lowestPitch = Infinity, lowestInterval = null;
  for (const n of notes) {
    if (n.pitch < lowestPitch) { lowestPitch = n.pitch; lowestInterval = ((n.pitchClass - root) + 12) % 12; }
  }
  for (const n of notes) {
    const iv = ((n.pitchClass - root) + 12) % 12;
    if (def.intervals.includes(iv)) {
      const w = memberWeight(iv);
      matchedSal += n.salience * w;
      matched.push({ onset: n.onset, pc: n.pitchClass, sal: n.salience, w, contrib: n.salience * w });
    } else {
      const p = Math.max(n.salience - NON_CHORD_TONE_FLOOR, 0);
      nctPen += p;
      nct.push({ onset: n.onset, pc: n.pitchClass, sal: n.salience, pen: p });
    }
  }
  let bassMult = 1.0;
  if (lowestInterval === 0) bassMult = 1.1;
  else if (lowestInterval === 7) bassMult = 0.9;
  else if (lowestInterval === 10 || lowestInterval === 11) bassMult = 0.8;
  const score = (matchedSal - nctPen) * bassMult;
  return { score, matched, nct, matchedSal, nctPen, bassMult, complexity: def.complexity };
}

function findCandidates(notes) {
  const pcs = new Set(notes.map(n => n.pitchClass));
  const cands = [];
  for (let root = 0; root < 12; root++) {
    if (!pcs.has(root)) continue;
    for (const [t] of Object.entries(CHORD_TYPES)) {
      const r = scoreChord(root, t, notes);
      if (r) cands.push({ root, type: t, ...r });
    }
  }
  cands.sort((a, b) => b.score - a.score);
  return cands;
}

// ─── standard forward/backward DP ─────────────────────────────────────────

function forwardDP(beatData) {
  const n = beatData.length;
  const dp = Array.from({ length: n }, () => new Map());
  for (let b = 0; b < n; b++) {
    const cands = beatData[b];
    if (b === 0) {
      dp[0].set('null', { total: 0, prev: null, chord: null, chain: 0 });
      for (const c of cands) {
        dp[0].set(c.key, { total: c.score - c.complexity * COMPLEXITY_PENALTY, prev: null, chord: c, chain: 1 });
      }
      continue;
    }
    let bestNullTotal = -Infinity, bestNullPrev = null;
    for (const [pk, ps] of dp[b - 1]) {
      if (ps.total > bestNullTotal) { bestNullTotal = ps.total; bestNullPrev = pk; }
    }
    dp[b].set('null', { total: bestNullTotal, prev: bestNullPrev, chord: null, chain: 0 });
    for (const c of cands) {
      let bestTotal = -Infinity, bestPrev = null, bestChain = 1;
      for (const [pk, ps] of dp[b - 1]) {
        const same = ps.chord && ps.chord.root === c.root && ps.chord.type === c.type;
        const chain = same ? ps.chain + 1 : 1;
        const t = ps.total + c.score - c.complexity * COMPLEXITY_PENALTY;
        if (t > bestTotal) { bestTotal = t; bestPrev = pk; bestChain = chain; }
      }
      const existing = dp[b].get(c.key);
      if (!existing || bestTotal > existing.total) {
        dp[b].set(c.key, { total: bestTotal, prev: bestPrev, chord: c, chain: bestChain });
      }
    }
  }
  return dp;
}

function backtrack(dp) {
  const n = dp.length;
  let bestKey = null, bestTotal = -Infinity;
  for (const [k, s] of dp[n - 1]) { if (s.total > bestTotal) { bestTotal = s.total; bestKey = k; } }
  const path = [];
  let cur = bestKey;
  for (let b = n - 1; b >= 0; b--) {
    const s = dp[b].get(cur);
    path.unshift({ beat: b, key: cur, chord: s.chord, total: s.total, chain: s.chain });
    cur = s.prev;
  }
  return path;
}

function backwardDP(beatData) {
  const n = beatData.length;
  const dp = Array.from({ length: n }, () => new Map());
  for (let b = n - 1; b >= 0; b--) {
    const cands = beatData[b];
    if (b === n - 1) {
      dp[b].set('null', { total: 0, next: null, chord: null, chain: 0 });
      for (const c of cands) {
        dp[b].set(c.key, { total: c.score - c.complexity * COMPLEXITY_PENALTY, next: null, chord: c, chain: 1 });
      }
      continue;
    }
    let bestNullTotal = -Infinity, bestNullNext = null;
    for (const [nk, ns] of dp[b + 1]) {
      if (ns.total > bestNullTotal) { bestNullTotal = ns.total; bestNullNext = nk; }
    }
    dp[b].set('null', { total: bestNullTotal, next: bestNullNext, chord: null, chain: 0 });
    for (const c of cands) {
      let bestTotal = -Infinity, bestNext = null, bestChain = 1;
      for (const [nk, ns] of dp[b + 1]) {
        const same = ns.chord && ns.chord.root === c.root && ns.chord.type === c.type;
        const chain = same ? ns.chain + 1 : 1;
        const t = ns.total + c.score - c.complexity * COMPLEXITY_PENALTY;
        if (t > bestTotal) { bestTotal = t; bestNext = nk; bestChain = chain; }
      }
      const existing = dp[b].get(c.key);
      if (!existing || bestTotal > existing.total) {
        dp[b].set(c.key, { total: bestTotal, next: bestNext, chord: c, chain: bestChain });
      }
    }
  }
  return dp;
}

// ─── path-dependent DP ────────────────────────────────────────────────────

function pathDependentDP(segments, numBeats, collectFn) {
  const dp = Array.from({ length: numBeats }, () => new Map());
  for (let b = 0; b < numBeats; b++) {
    const allNotes = collectFn(segments, b);
    if (b === 0) {
      dp[0].set('null|-Inf', { total: 0, prevSK: null, chord: null, chain: 0, boundary: -Infinity });
      const cands = findCandidates(allNotes);
      for (const c of cands) {
        const bnd = c.matched.length > 0 ? Math.max(...c.matched.map(m => m.onset)) : -Infinity;
        const sk = `${c.root}-${c.type}|${bnd}`;
        const t = c.score - c.complexity * COMPLEXITY_PENALTY;
        const ex = dp[0].get(sk);
        if (!ex || t > ex.total) {
          dp[0].set(sk, { total: t, prevSK: null, chord: c, chain: 1, boundary: bnd });
        }
      }
      continue;
    }
    const updates = new Map();
    for (const [prevSK, prevState] of dp[b - 1]) {
      const prevChord = prevState.chord;
      const prevBoundary = prevState.boundary;
      const prevCK = prevChord ? `${prevChord.root}-${prevChord.type}` : 'null';
      {
        const sk = `null|${prevBoundary}`;
        const ex = updates.get(sk);
        if (!ex || prevState.total > ex.total) {
          updates.set(sk, { total: prevState.total, prevSK, chord: null, chain: 0, boundary: prevBoundary });
        }
      }
      const pcsAll = new Set(allNotes.map(n => n.pitchClass));
      for (let root = 0; root < 12; root++) {
        if (!pcsAll.has(root)) continue;
        for (const [typeName] of Object.entries(CHORD_TYPES)) {
          const candCK = `${root}-${typeName}`;
          const same = (candCK === prevCK);
          const filtered = same ? allNotes : allNotes.filter(n => n.onset > prevBoundary);
          const result = scoreChord(root, typeName, filtered);
          if (!result) continue;
          const chain = same ? prevState.chain + 1 : 1;
          const t = prevState.total + result.score - result.complexity * COMPLEXITY_PENALTY;
          const bnd = result.matched.length > 0 ? Math.max(...result.matched.map(m => m.onset)) : prevBoundary;
          const sk = `${candCK}|${bnd}`;
          const ex = updates.get(sk);
          if (!ex || t > ex.total) {
            updates.set(sk, { total: t, prevSK, chord: { key: candCK, root, type: typeName, ...result }, chain, boundary: bnd });
          }
        }
      }
    }
    dp[b] = updates;
  }
  const n = numBeats;
  let bestSK = null, bestTotal = -Infinity;
  for (const [sk, s] of dp[n - 1]) { if (s.total > bestTotal) { bestTotal = s.total; bestSK = sk; } }
  const path = [];
  let cur = bestSK;
  for (let b = n - 1; b >= 0; b--) {
    const s = dp[b].get(cur);
    path.unshift({ beat: b, key: s.chord ? `${s.chord.root}-${s.chord.type}` : 'null', chord: s.chord, total: s.total, chain: s.chain, boundary: s.boundary });
    cur = s.prevSK;
  }
  return { dp, path };
}

// ─── four approaches ──────────────────────────────────────────────────────

function approachA(segments, numBeats) {
  return pathDependentDP(segments, numBeats, collectBidirectional);
}

function approachB(segments, numBeats) {
  const p1BeatData = [];
  for (let b = 0; b < numBeats; b++) {
    const notes = collectPast(segments, b);
    const cands = findCandidates(notes);
    p1BeatData.push(cands.map(c => ({ key: `${c.root}-${c.type}`, ...c })));
  }
  const fwd = forwardDP(p1BeatData);
  const bwd = backwardDP(p1BeatData);
  const p1path = [];
  for (let b = 0; b < numBeats; b++) {
    let bestKey = 'null', bestCombined = -Infinity, bestChord = null;
    for (const [key, fs] of fwd[b]) {
      const bs = bwd[b].get(key);
      if (!bs) continue;
      const localScore = fs.chord ? fs.chord.score - fs.chord.complexity * COMPLEXITY_PENALTY : 0;
      const combined = fs.total + bs.total - localScore;
      if (combined > bestCombined) { bestCombined = combined; bestKey = key; bestChord = fs.chord; }
    }
    p1path.push({ beat: b, key: bestKey, chord: bestChord, total: bestCombined });
  }
  const p1info = p1path.map(p => {
    if (!p.chord) return { chordKey: 'null', matchedOnsets: [] };
    return { chordKey: p.key, matchedOnsets: p.chord.matched.map(m => m.onset) };
  });
  const p2BeatData = [];
  for (let b = 0; b < numBeats; b++) {
    const allNotes = collectPast(segments, b);
    const pcs = new Set(allNotes.map(n => n.pitchClass));
    const cands = [];
    for (let root = 0; root < 12; root++) {
      if (!pcs.has(root)) continue;
      for (const [typeName] of Object.entries(CHORD_TYPES)) {
        const candKey = `${root}-${typeName}`;
        let boundary = -Infinity;
        for (let pb = 0; pb < b; pb++) {
          if (p1info[pb].chordKey === candKey || p1info[pb].chordKey === 'null') continue;
          for (const onset of p1info[pb].matchedOnsets) { if (onset > boundary) boundary = onset; }
        }
        const filtered = allNotes.filter(n => {
          const noteBeat = Math.floor(n.onset);
          if (noteBeat < p1info.length && p1info[noteBeat].chordKey === candKey) return true;
          if (n.onset > boundary) return true;
          return false;
        });
        const result = scoreChord(root, typeName, filtered);
        if (result) cands.push({ key: candKey, root, type: typeName, ...result });
      }
    }
    cands.sort((a, b) => b.score - a.score);
    p2BeatData.push(cands);
  }
  const p2dp = forwardDP(p2BeatData);
  return { p1path, fwd, bwd, p2dp, path: backtrack(p2dp), p1BeatData, p2BeatData };
}

function approachC(segments, numBeats) {
  const p1BeatData = [];
  for (let b = 0; b < numBeats; b++) {
    const notes = collectPast(segments, b);
    const cands = findCandidates(notes);
    p1BeatData.push(cands.map(c => ({ key: `${c.root}-${c.type}`, ...c })));
  }
  const p1dp = forwardDP(p1BeatData);
  const p1path = backtrack(p1dp);
  const p1info = p1path.map(p => {
    if (!p.chord) return { chordKey: 'null', matchedOnsets: [] };
    return { chordKey: p.key, matchedOnsets: p.chord.matched.map(m => m.onset) };
  });
  const p2BeatData = [];
  for (let b = 0; b < numBeats; b++) {
    const allNotes = collectPast(segments, b);
    const pcs = new Set(allNotes.map(n => n.pitchClass));
    const cands = [];
    for (let root = 0; root < 12; root++) {
      if (!pcs.has(root)) continue;
      for (const [typeName] of Object.entries(CHORD_TYPES)) {
        const candKey = `${root}-${typeName}`;
        let boundary = -Infinity;
        for (let pb = 0; pb < b; pb++) {
          if (p1info[pb].chordKey === candKey || p1info[pb].chordKey === 'null') continue;
          for (const onset of p1info[pb].matchedOnsets) { if (onset > boundary) boundary = onset; }
        }
        const filtered = allNotes.filter(n => {
          const noteBeat = Math.floor(n.onset);
          if (noteBeat < p1info.length && p1info[noteBeat].chordKey === candKey) return true;
          if (n.onset > boundary) return true;
          return false;
        });
        const result = scoreChord(root, typeName, filtered);
        if (result) cands.push({ key: candKey, root, type: typeName, ...result });
      }
    }
    cands.sort((a, b) => b.score - a.score);
    p2BeatData.push(cands);
  }
  const p2dp = forwardDP(p2BeatData);
  return { p1path, p1dp, p2dp, path: backtrack(p2dp), p1BeatData, p2BeatData };
}

function approachD(segments, numBeats) {
  return pathDependentDP(segments, numBeats, collectPast);
}

// ─── display ──────────────────────────────────────────────────────────────

function showBeatDetail(dp, beat, top) {
  top = top || 4;
  const map = dp[beat];
  const entries = [...map.entries()]
    .filter(([k]) => k !== 'null' && !k.startsWith('null'))
    .sort((a, b) => b[1].total - a[1].total)
    .slice(0, top);
  if (entries.length === 0) { log(`    beat ${beat}: (no candidates)`); return; }
  const nullEntry = [...map.entries()].find(([k]) => k === 'null' || k.startsWith('null|'));
  const nullTotal = nullEntry ? nullEntry[1].total : -Infinity;
  log(`    beat ${beat}: (null total=${nullTotal.toFixed(3)})`);
  for (const [k, s] of entries) {
    const name = s.chord ? cn(s.chord.root, s.chord.type) : '-';
    const local = s.chord ? s.chord.score.toFixed(3) : '0';
    const cplx = s.chord ? `cplx=${s.chord.complexity}` : '';
    const nctInfo = s.chord && s.chord.nct.length > 0
      ? ` nct=[${s.chord.nct.map(n => `${pcName(n.pc)}:${n.pen.toFixed(3)}`).join(',')}]` : '';
    const matchInfo = s.chord
      ? ` match=[${s.chord.matched.map(m => `${pcName(m.pc)}@${m.onset}:${m.contrib.toFixed(3)}`).join(',')}]` : '';
    const bndInfo = s.boundary !== undefined ? ` bnd=${s.boundary}` : '';
    log(`      ${name.padEnd(8)} total=${s.total.toFixed(3)}  local=${local}  ${cplx}${nctInfo}${matchInfo}${bndInfo}`);
  }
}

function showResult(label, result, dp) {
  log(`\n  ${label}`);
  for (let b = 0; b < dp.length; b++) showBeatDetail(dp, b);
  const ranges = [];
  for (const r of result) {
    const name = r.chord ? cn(r.chord.root, r.chord.type) : '-';
    const last = ranges[ranges.length - 1];
    if (last && last.name === name) last.end = r.beat;
    else ranges.push({ start: r.beat, end: r.beat, name });
  }
  const prog = ranges.map(r => r.name).filter(n => n !== '-').join(' -> ');
  log(`\n  RESULT: ${prog}  (total=${result[result.length - 1].total.toFixed(3)})`);
}

// ─── run ──────────────────────────────────────────────────────────────────

let lines = [];
function log(s) { lines.push(s); }

function runTest(pitchNames, duration, label) {
  const notes = makeNotes(pitchNames, duration);
  const segments = preprocessNotes(notes);
  const numBeats = Math.ceil(notes[notes.length - 1].onset + notes[notes.length - 1].duration);
  log(`\n${'='.repeat(78)}`);
  log(`  ${label}  (${pitchNames.join(' ')}, dur=${duration}, ${numBeats} beats)`);
  log('='.repeat(78));
  log('\n  Notes per beat:');
  for (let b = 0; b < numBeats; b++) {
    const past = collectPast(segments, b);
    const desc = past.map(n => `${pcName(n.pitchClass)}@${n.onset}(${n.salience.toFixed(3)})`).join('  ');
    log(`    beat ${b}: ${desc}`);
  }
  const a = approachA(segments, numBeats);
  showResult('A - Bidirectional + path-dependent boundary', a.path, a.dp);
  const bRes = approachB(segments, numBeats);
  log(`\n  B - Fwd+Bwd combined two-pass`);
  log(`    Pass 1 (fwd+bwd): ${bRes.p1path.map(p => p.chord ? cn(p.chord.root, p.chord.type) : '-').join(' | ')}`);
  showResult('    Pass 2 (constrained):', bRes.path, bRes.p2dp);
  const c = approachC(segments, numBeats);
  log(`\n  C - Forward-only two-pass`);
  log(`    Pass 1 (fwd): ${c.p1path.map(p => p.chord ? cn(p.chord.root, p.chord.type) : '-').join(' | ')}`);
  showResult('    Pass 2 (constrained):', c.path, c.p2dp);
  const d = approachD(segments, numBeats);
  showResult('D - Path-dependent boundary (past-only)', d.path, d.dp);
}

// ─── UI ───────────────────────────────────────────────────────────────────

function setMel(s) { document.getElementById('mel').value = s; }

function parseMel() {
  return document.getElementById('mel').value.trim().split(/\s+/).filter(Boolean);
}

function flush() {
  document.getElementById('output').textContent = lines.join('\n');
  lines = [];
}

function runAll() {
  lines = [];
  const mel = parseMel();
  if (mel.length < 2) { document.getElementById('output').textContent = 'Need at least 2 notes.'; return; }
  log(`Harmonic Analysis Lab   Decay=${DECAY_RATE}, complexity_penalty=${COMPLEXITY_PENALTY}/level`);
  runTest(mel, 2, 'HALF NOTES');
  runTest(mel, 1, 'QUARTER NOTES');
  runTest(mel, 0.5, 'EIGHTH NOTES');
  runTest(mel, 0.25, 'SIXTEENTH NOTES');
  flush();
}

function runOne() {
  lines = [];
  const mel = parseMel();
  const dur = parseFloat(document.getElementById('dur').value);
  if (mel.length < 2) { document.getElementById('output').textContent = 'Need at least 2 notes.'; return; }
  const labels = { 2: 'HALF NOTES', 1: 'QUARTER NOTES', 0.5: 'EIGHTH NOTES', 0.25: 'SIXTEENTH NOTES' };
  log(`Harmonic Analysis Lab   Decay=${DECAY_RATE}, complexity_penalty=${COMPLEXITY_PENALTY}/level`);
  runTest(mel, dur, labels[dur] || `dur=${dur}`);
  flush();
}

// Run on load
runAll();
</script>
</body>
</html>
